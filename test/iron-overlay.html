<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>

<head>

  <title>iron-overlay tests</title>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">

  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>

  <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
  <link rel="import" href="../iron-overlay.html">
  <style>
    html {
      overflow: hidden;
    }
  </style>
</head>

<body>

  <test-fixture id="basic">
    <template>
      <iron-overlay>
        <template>
          Basic Overlay
          <button autofocus>autofocused</button>
        </template>
      </iron-overlay>
    </template>
  </test-fixture>

  <test-fixture id="scoped">
    <template>
      <iron-overlay>
        <template>
          <style>
            * {
              color: red;
            }
          </style>
          <button autofocus>autofocused</button>
        </template>
      </iron-overlay>
    </template>
  </test-fixture>

  <test-fixture id="opened">
    <template>
      <iron-overlay opened>
        <template>
          Basic Overlay
        </template>
      </iron-overlay>
    </template>
  </test-fixture>

  <test-fixture id="multiple">
    <template>
      <iron-overlay class="overlay-1">
        <template>
          Test overlay 1
          <button>Click</button>
        </template>
      </iron-overlay>
      <iron-overlay class="overlay-2">
        <template>
          Test overlay 2
          <button>Click</button>
        </template>
      </iron-overlay>
    </template>
  </test-fixture>

  <button id="button0">button0</button>
  <button id="button1">button1</button>
  <script>
    let overlay;

    suite('basic overlay', () => {

      setup(() => {
        overlay = fixture('basic');
      });

      test('overlay starts hidden', () => {
        assert.isNotOk(overlay.opened, 'overlay starts closed');
        assert.isNotOk(overlay.renderer, 'overlay w/o renderer');
      });

      test('overlay creates and opens the renderer', () => {
        overlay.opened = true;
        assert.isOk(overlay.renderer, 'renderer initialized');
        assert.isTrue(overlay.renderer.opened, 'renderer opened');
      });

      test('overlay delegates renderer hosting via iron-overlay-attach', done => {
        overlay.addEventListener('iron-overlay-attach', event => {
          assert.isTrue(event.bubbles, 'bubbling event');
          assert.isTrue(event.cancelable, 'cancelable event');
          done();
        });
        overlay.opened = true;
      });

      test('overlay renderer attached on body', () => {
        overlay.opened = true;
        assert.isTrue(document.body.contains(overlay.renderer), 'renderer attached to body');
      });

      test('overlay fires iron-overlay-opened', done => {
        const spy = sinon.stub();
        overlay.addEventListener('iron-overlay-opened', spy);
        runAfterOpen(overlay, () => {
          assert.isTrue(spy.calledOnce, 'opened event fired once');
          done();
        });
      });

      test('overlay fires iron-overlay-closed', done => {
        const spy = sinon.stub();
        overlay.addEventListener('iron-overlay-opened', spy);
        overlay.addEventListener('iron-overlay-closed', spy);
        runAfterOpen(overlay, () => {
          runAfterClose(overlay, () => {
            assert.isTrue(spy.calledTwice, 'opened and closed events fired');
            done();
          });
        });
      });

      test('close an overlay quickly after open', done => {
        // first, open the overlay
        overlay.opened = true;
        setTimeout(() => {
          // during the opening transition, close the overlay
          this.opened = false;
          // wait for any exceptions to be thrown until the transition is done.
          setTimeout(() => {
            done();
          }, 300);
        });
      });

      test('clicking an overlay does not close it', done => {
        runAfterOpen(overlay, () => {
          const spy = sinon.stub();
          overlay.addEventListener('iron-overlay-closed', spy);
          MockInteractions.tap(overlay.renderer.$.overlay);
          setTimeout(() => {
            assert.isFalse(spy.called, 'iron-overlay-closed should not fire');
            done();
          }, 100);
        });
      });

      test('clicking outside an overlay closes it', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-closed', () => {
            done();
          });
          MockInteractions.tap(document.elementFromPoint(2, 2));
        });
      });

      test('clicking outside an overlay with-backdrop closes it', done => {
        overlay.withBackdrop = true;
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-closed', () => {
            done();
          });
          MockInteractions.tap(document.elementFromPoint(2, 2));
        });
      });

      test('open overlay on mousedown does not close it', done => {
        const btn = document.createElement('button');
        btn.addEventListener('mousedown', () => overlay.opened = true);
        document.body.appendChild(btn);
        // It triggers mousedown, mouseup, and click.
        MockInteractions.tap(btn);
        document.body.removeChild(btn);

        assert.isTrue(overlay.opened, 'overlay opened');
        setTimeout(() => {
          assert.isTrue(overlay.opened, 'overlay is still open');
          done();
        }, 10);
      });

      test('clicking outside fires iron-overlay-canceled', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-canceled', event => {
            assert.equal(event.detail.target, document.body, 'detail contains original click event');
            done();
          });
          MockInteractions.tap(document.body);
        });
      });

      test('clicking outside closes the overlay', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-closed', event => {
            assert.isTrue(event.detail.canceled, 'overlay is canceled');
            done();
          });
          MockInteractions.tap(document.body);
        });
      });

      test('iron-overlay-canceled event can be prevented', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-canceled', event => {
            event.preventDefault();
          });
          const spy = sinon.stub();
          overlay.addEventListener('iron-overlay-closed', spy);
          MockInteractions.tap(document.body);
          setTimeout(() => {
            assert.isTrue(overlay.opened, 'overlay is still open');
            assert.isFalse(spy.called, 'iron-overlay-closed not fired');
            done();
          }, 10);
        });
      });

      test('cancel an overlay with esc key', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-canceled', event => {
            assert.equal(event.detail.type, 'keydown');
            done();
          });
          MockInteractions.pressAndReleaseKeyOn(document, 27);
        });
      });

      test('close an overlay with esc key', done => {
        runAfterOpen(overlay, () => {
          overlay.addEventListener('iron-overlay-closed', event => {
            assert.isTrue(event.detail.canceled, 'overlay is canceled');
            done();
          });
          MockInteractions.pressAndReleaseKeyOn(document, 27);
        });
      });

      test('no-cancel-on-outside-click property', done => {
        overlay.noCancelOnOutsideClick = true;
        runAfterOpen(overlay, () => {
          const spy = sinon.stub();
          overlay.addEventListener('iron-overlay-closed', spy);
          MockInteractions.tap(document.body);
          setTimeout(() => {
            assert.isFalse(spy.called, 'iron-overlay-closed should not fire');
            done();
          }, 10);
        });
      });

      test('no-cancel-on-esc-key property', done => {
        overlay.noCancelOnEscKey = true;
        runAfterOpen(overlay, () => {
          const spy = sinon.stub();
          overlay.addEventListener('iron-overlay-closed', spy);
          MockInteractions.pressAndReleaseKeyOn(document, 27);
          setTimeout(() => {
            assert.isFalse(spy.called, 'iron-overlay-cancel should not fire');
            done();
          }, 10);
        });
      });

    });

    suite('opened overlay', () => {

      setup(() => {
        overlay = fixture('opened');
      });

      test('overlay open by default', () => {
        assert.isTrue(overlay.opened, 'overlay starts opened');
        assert.isOk(overlay.renderer, 'overlay has a renderer');
      });

      test('overlay positioned & sized properly', done => {
        setTimeout(() => {
          const rect = overlay.renderer.$.overlay.getBoundingClientRect();
          assert.closeTo(rect.left, (window.innerWidth - rect.width) / 2, 1, 'centered horizontally');
          assert.closeTo(rect.top, (window.innerHeight - rect.height) / 2, 1, 'centered vertically');
          done();
        }, 10);
      });
    });

    const waitNextEvent = (el, event) =>
      new Promise(resolve => el.addEventListener(event, resolve));

    const openPromise = overlay => {
      overlay.opened = true;
      return waitNextEvent(overlay, 'iron-overlay-opened');
    };

    const closePromise = overlay => {
      overlay.opened = false;
      return waitNextEvent(overlay, 'iron-overlay-closed');
    };

    suite('attach/detach', () => {

      setup(() => {
        overlay = fixture('basic');
      });

      test('detached overlay does not create the renderer', done => {
        const spy = sinon.stub();
        overlay.addEventListener('iron-overlay-opened', spy);
        overlay.parentNode.removeChild(overlay);
        overlay.opened = true;
        assert.isNotOk(overlay.renderer, 'renderer not initialized');
        setTimeout(() => {
          assert.isFalse(spy.called, 'iron-overlay-opened should not fire');
          done();
        }, 100);
      });

      test('removing overlay from the DOM closes it', done => {
        openPromise(overlay)
          .then(() => {
            overlay.parentNode.removeChild(overlay);
            assert.isFalse(overlay.opened, 'overlay not closed');
            return waitNextEvent(overlay, 'iron-overlay-closed');
          })
          .then(() => done())
          .catch(done);
      });

      test('reparenting overlay keeps it opened', done => {
        openPromise(overlay)
          .then(() => {
            document.body.appendChild(overlay);
            assert.isTrue(overlay.opened, 'overlay not opened');
            return waitNextEvent(overlay, 'iron-overlay-opened');
          })
          .then(() => done())
          .catch(done);
      });

      test('focus restoring works when reparenting overlay', done => {
        const parent = overlay.parentNode;
        openPromise(overlay)
          .then(() => {
            button0.focus();
            document.body.appendChild(overlay);
            return waitNextEvent(overlay, 'iron-overlay-opened');
          })
          .then(() => closePromise(overlay))
          .then(() => {
            assert.equal(getDeepActiveElement(), button0, 'focus not returned to button');
            done();
          })
          .catch(done);
      });
    });

    focusSuiteForFixture('basic');

    focusSuiteForFixture('scoped');

    suite('multiple overlays', () => {
      let overlay1,
        overlay2;

      setup(() => {
        const f = fixture('multiple');
        overlay1 = f[0];
        overlay2 = f[1];
      });

      test('ESC closes only the top overlay', done => {
        runAfterOpen(overlay1, () => {
          runAfterOpen(overlay2, () => {
            MockInteractions.pressAndReleaseKeyOn(document, 27);
            assert.isFalse(overlay2.opened, 'overlay2 was closed');
            assert.isTrue(overlay1.opened, 'overlay1 is still opened');
            done();
          });
        });
      });

      test('ESC event handling is delegated to interested overlay', done => {
        overlay2.noCancelOnEscKey = true;
        runAfterOpen(overlay1, () => {
          runAfterOpen(overlay2, () => {
            MockInteractions.pressAndReleaseKeyOn(document, 27);
            assert.isTrue(overlay2.opened, 'overlay2 still opened');
            assert.isFalse(overlay1.opened, 'overlay1 closed');
            done();
          });
        });
      });

      test('click event handling is delegated to interested overlay', done => {
        overlay2.noCancelOnOutsideClick = true;
        runAfterOpen(overlay1, () => {
          runAfterOpen(overlay2, () => {
            MockInteractions.tap(document.body);
            assert.isTrue(overlay2.opened, 'overlay2 still opened');
            assert.isFalse(overlay1.opened, 'overlay1 closed');
            done();
          });
        });
      });

      test('button click event handling closes only top overlay', done => {
        overlay2.noCancelOnOutsideClick = true;
        runAfterOpen(overlay1, () => {
          runAfterOpen(overlay2, () => {
            const button = overlay2.contentHost.querySelector('button');
            button.addEventListener('click', () => overlay2.opened = false);
            MockInteractions.tap(button);
            assert.isFalse(overlay2.opened, 'overlay2 closed');
            assert.isTrue(overlay1.opened, 'overlay1 still opened');
            done();
          });
        });
      });

      test('close an overlay in proximity to another overlay', done => {
        // Open and close a separate overlay.
        overlay1.opened = true;
        overlay1.opened = false;

        // Open the overlay we care about.
        overlay2.opened = true;

        // Immediately close the first overlay. Wait for infinite recursion, otherwise we win.
        runAfterClose(overlay2, () => {
          done();
        })
      });

    });

    suite('scoped overlay', () => {

      setup(() => {
        overlay = fixture('scoped');
        overlay.opened = true;
      });

      test('can query content', () => {
        assert.isOk(overlay.contentHost.querySelector('button'));
      });

      test('can listen to non-composed events content', () => {
        const spy = sinon.spy();
        overlay.contentHost.addEventListener('some-event', spy);
        overlay.contentHost.querySelector('button').dispatchEvent(new CustomEvent('some-event', {
          bubbles: true,
          composed: false
        }));
        assert.equal(spy.callCount, 1);
      });

      test('styles are scoped', () => {
        // Force distribution & styling.
        window.ShadyDOM && ShadyDOM.flush();
        assert.notEqual(
          getComputedStyle(overlay.renderer).color,
          'rgb(255, 0, 0)',
          'outside content color ok');
        assert.equal(
          getComputedStyle(overlay.contentHost.querySelector('button')).color,
          'rgb(255, 0, 0)',
          'content in overlay color ok');
      });

    });

    function runAfterOpen(overlay, callback) {
      overlay.addEventListener('iron-overlay-opened', callback);
      overlay.opened = true;
    }

    function runAfterClose(overlay, callback) {
      overlay.addEventListener('iron-overlay-closed', callback);
      overlay.opened = false;
    }

    function getDeepActiveElement() {
      let active = document.activeElement;
      while (active && active.shadowRoot && active.shadowRoot.activeElement) {
        active = active.shadowRoot.activeElement;
      }
      return active;
    }

    function focusSuiteForFixture(fixtureName) {
      return suite(fixtureName + ' overlay focus handling', () => {

        setup(() => {
          overlay = fixture(fixtureName);
        });

        test('node with autofocus is focused', done => {
          runAfterOpen(overlay, () => {
            const autofocused = overlay.contentHost.querySelector('[autofocus]');
            assert.equal(getDeepActiveElement(), autofocused,
              '<button autofocus> is focused');
            done();
          });
        });

        test('no-auto-focus will not focus node with autofocus', done => {
          overlay.noAutoFocus = true;
          runAfterOpen(overlay, () => {
            const autofocused = overlay.contentHost.querySelector('[autofocus]');
            assert.notEqual(getDeepActiveElement(), autofocused,
              '<button autofocus> not focused after opened');
            done();
          });
          // In Safari the element with autofocus will immediately receive focus when displayed for the first time http://jsbin.com/woroci/2/ Ensure this is not the case for overlay.
          const autofocused = overlay.contentHost.querySelector('[autofocus]');
          assert.notEqual(getDeepActiveElement(), autofocused,
            '<button autofocus> not immediately focused');
        });

        suite('restore focus', () => {
          setup(() => {
            button0.focus();
          });

          test('restores focus to previous focusable', done => {
            runAfterOpen(overlay, () => {
              runAfterClose(overlay, () => {
                assert.equal(getDeepActiveElement(), button0, 'focus returned to button');
                done();
              });
            });
          });

          test('avoids restoring focus if focus changed', done => {
            runAfterOpen(overlay, () => {
              button1.focus();
              runAfterClose(overlay, () => {
                assert.equal(getDeepActiveElement(), button1, 'focus was not modified');
                done();
              });
            });
          });
        });

      });
    }
  </script>

</body>

</html>