<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="iron-overlay-renderer.html">

<!--
`iron-overlay` is an element that can be hidden or shown, and displays on top of other content.
It can be used to implement a variety of UI controls including dialogs and drop downs.
Multiple overlays may be displayed at once.

`iron-overlay` delegates rendering of the overlay content to a renderer (`iron-overlay-renderer`).
It won't host the renderer, but request another element to host it through the
events `iron-overlay-attach` and `iron-overlay-detach`.
It requires overlay contents to be contained in a `<template>` (since they need to be hosted in the renderer).

Ensure to add an `iron-overlay-container` in your document in order to display
overlays. Insert it in a stacking-context safe node (e.g. `document.body`).

    <div style="transform: translateZ(0);">
      This div creates a new stacking context
      <iron-overlay opened>
        <template>
          <h2>Hello world!</h2>
        </template>
      </iron-overlay>
    </div>

    <iron-overlay-container></iron-overlay-container>


### Closing and canceling

An overlay may be hidden by closing or canceling. The difference between close and cancel is user
intent. Closing generally implies that the user acknowledged the content on the overlay. By default,
it will cancel whenever the user taps outside it or presses the escape key. This behavior is
configurable with the `no-cancel-on-esc-key` and the `no-cancel-on-outside-click` properties.
`close()` should be called explicitly by the implementer when the user interacts with a control
in the overlay element. When the overlay is canceled, it fires an 'iron-overlay-canceled'
event. Call `preventDefault` on this event to prevent the overlay from closing.


### Styling

`iron-overlay` sets its renderer attribute `data-overlay` to its id, so that
styling can be done like this:

    <style is="custom-style">
      iron-overlay-renderer {
        --iron-overlay-background-color: yellow;
      }
      iron-overlay-renderer[data-overlay="overlay1"] {
        --iron-overlay-background-color: orange;
      }
    </style>

    <iron-overlay-container></iron-overlay-container>

    <iron-overlay>
      <template>Overlay Content</template>
    </iron-overlay>
    <iron-overlay id="overlay1">
      <template>Overlay 1 Content</template>
    </iron-overlay>

@demo demo/index.html
 -->
<dom-module id="iron-overlay">
  <template>
    <slot></slot>
    <template id="renderer-template">
      <iron-overlay-renderer
        opened$="[[opened]]"
        animated$="[[animated]]"
        with-backdrop$="[[withBackdrop]]"></iron-overlay-renderer>
    </template>
  </template>

  <script>
    (function() {
      'use strict';

      const templatizer = new Polymer.Templatizer();

      /* Symbols for private properties/methods */
      const _openedChanged = Symbol();
      const _ensureInstance = Symbol();
      const _ensureAttached = Symbol();
      const _ensureDetached = Symbol();
      const _onTransitioningChanged = Symbol();
      const _fire = Symbol();

      const _onTap = Symbol();
      const _onKeydown = Symbol();
      const _isTapInside = Symbol();

      const _eventHandler = Symbol();

      class IronOverlay extends Polymer.Element {

        static get is() {
          return 'iron-overlay';
        }

        static get config() {
          return {
            properties: {

              /**
               * True if the overlay is currently displayed.
               */
              opened: {
                type: Boolean,
                notify: true,
                observer: _openedChanged
              },

              /**
               * True if the overlay has open/close animation.
               */
              animated: {
                type: Boolean
              },

              /**
               * True if the overlay should have a backdrop.
               */
              withBackdrop: {
                type: Boolean
              },

              /**
               * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
               * `iron-overlay` provides the `canceled` reason.
               */
              closingReason: {
                type: Object,
                readOnly: true,
                value: function() {
                  return {
                    canceled: false
                  };
                }
              },

              /**
               * Set to true to disable canceling the overlay with the ESC key.
               */
              noCancelOnEscKey: {
                type: Boolean
              },

              /**
               * Set to true to disable canceling the overlay by clicking outside it.
               */
              noCancelOnOutsideClick: {
                type: Boolean
              },

              /**
               * Set to true to disable auto-focusing the overlay or child nodes with
               * the `autofocus` attribute when the overlay is opened.
               */
              noAutoFocus: {
                type: Boolean
              },

              /**
               * The renderer for the overlay.
               */
              renderer: {
                type: Polymer.IronOverlayRenderer,
                readOnly: true
              }
            }
          };
        }

        constructor() {
          super();
          this[_onTap] = this[_onTap].bind(this);
          this[_onKeydown] = this[_onKeydown].bind(this);
          this[_eventHandler] = this[_eventHandler].bind(this);
        }

        connectedCallback() {
          super.connectedCallback();
          this.opened && this[_openedChanged](this.opened);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this[_ensureDetached]();
        }

        /**
         * Toggle the opened state of the overlay.
         */
        toggle() {
          this.opened ? this.close() : this.open();
        }

        /**
         * Open the overlay.
         */
        open() {
          this.closingReason.canceled = false;
          this.opened = true;
        }

        /**
         * Close the overlay.
         */
        close() {
          this.closingReason.canceled = false;
          this.opened = false;
        }

        /**
         * Focuses the overlay if opened, blurs it if closed.
         */
        applyFocus() {
          if (this.noAutoFocus || !this.renderer) {
            return;
          }
          const focusNode = this._getFocusNode();
          if (this.opened) {
            focusNode && focusNode.focus();
          } else {
            focusNode && focusNode.blur();
          }
        }

        /**
         * The node to be focused when the overlay is opened.
         * Defaults to the child with `autofocus` or the overlay itself.
         * @protected
         */
        _getFocusNode() {
          return this.renderer.querySelector('[autofocus]') || this.renderer;
        }

        /**
         * The template containing the renderer.
         * @type {!HTMLTemplateElement}
         * @protected
         */
        _getRendererTemplate() {
          return this.$['renderer-template'];
        }

        /**
         * The template containing the content to be stamped in the renderer.
         * @type {!HTMLTemplateElement}
         * @protected
         */
        _getContentTemplate() {
          return this.querySelector('template');
        }

        /**
         * Fires `iron-overlay-canceled` event to notify that the overlay is about
         * to be closed, and if this event is not prevented, it proceeds to
         * close the overlay.
         * @param {!Event} event The original event
         * @protected
         */
        _cancel(event) {
          const cancelEvent = this[_fire]('iron-overlay-canceled', event, {
            cancelable: true
          });
          if (!cancelEvent.defaultPrevented) {
            this.closingReason.canceled = true;
            this.opened = false;
          }
        }

        /**
         * Toggles the listeners according to `opened`.
         * @protected
         */
        _toggleListeners() {
          const method = this.opened ? 'addEventListener' : 'removeEventListener';
          // Document wide listeners.
          document[method]('mousedown', this[_onTap], {
            passive: true
          });
          document[method]('touchstart', this[_onTap], {
            passive: true
          });
          document[method]('keydown', this[_onKeydown]);

          document[method]('iron-overlay-event-handler', this[_eventHandler]);
        }

        /**
         * Returns true if the event can be handled by the overlay.
         * @param {!Event} event The original event
         * @returns {boolean}
         * @protected
         */
        _canHandleEvent(event) {
          if (event.type === 'keydown') {
            return (event.key === 'Escape' || event.keyCode === 27) && !this.noCancelOnEscKey;
          }
          if (event.type === 'mousedown' || event.type === 'touchstart') {
            return !this.noCancelOnOutsideClick;
          }
          return false;
        }

        /**
         * Returns true if the overlay should be handling the event.
         * It fires a `iron-overlay-event-handler` to check if there is another
         * overlay on that should take care of the event.
         * @param {!Event} event
         * @param {boolean}
         * @protected
         */
        _shouldHandleEvent(event) {
          // Don't fire event if cannot even handle it!
          if (!this._canHandleEvent(event)) {
            return false;
          }
          var handlerEvent = this[_fire]('iron-overlay-event-handler', {
            sourceEvent: event,
            handler: this
          }, {
            node: document
          });
          return (handlerEvent.detail.handler === this);
        }

        /**
         * @param {!Event} event
         * @returns {boolean}
         */
        [_isTapInside](event) {
          return event.composedPath().indexOf(this.renderer.$.overlay) !== -1;
        }

        /**
         * @param {!Event} event
         */
        [_onKeydown](event) {
          if (this._shouldHandleEvent(event)) {
            // Avoid event handling conflicts with native overlays like <dialog>.
            // E.g. ESC key should not bubble up to the native dialog.
            // Needs to be synchronous.
            event.preventDefault();
            this._cancel(event);
          }
        }

        /**
         * @param {!Event} event
         */
        [_onTap](event) {
          // If it should handle the event it means it is the top overlay.
          // If the tap is outside, we should cancel it.
          if (this._shouldHandleEvent(event) && !this[_isTapInside](event)) {
            this._cancel(event);
          };
        }

        [_eventHandler](event) {
          if (this._canHandleEvent(event.detail.sourceEvent)) {
            event.detail.handler = this;
          }
        }

        /**
         * Ensures the overlay is created and the content is stamped and appended into the overlay.
         */
        [_ensureInstance]() {
          if (this.renderer) {
            return;
          }
          // Init the renderer.
          const rendererInstance = new(templatizer.templatize(this._getRendererTemplate(), {
            fwdHostPropToInstance: function(host, prop, value) {
              rendererInstance && rendererInstance.forwardProperty(prop, value, host);
            }
          }))(this);
          const renderer = rendererInstance.root.children[0];
          renderer.dataset.overlay = this.id;
          renderer.addEventListener('transitioning-changed', this[_onTransitioningChanged].bind(this));

          // Stamp the content if any!
          const contentTemplate = this._getContentTemplate();
          if (contentTemplate) {
            const contentInstance = new(templatizer.templatize(contentTemplate, {
              fwdHostPropToInstance: function(host, prop, value) {
                contentInstance && contentInstance.forwardProperty(prop, value, host);
              }
            }))(this);
            // Append children to renderer.
            renderer.appendChild(contentInstance.root);
          }

          this._setRenderer(renderer);
        }

        /**
         * Ensures the renderer is attached.
         */
        [_ensureAttached]() {
          this[_ensureInstance]();
          if (this.renderer.isConnected) {
            return;
          }
          const event = this[_fire]('iron-overlay-attach', {
            overlay: this
          }, {
            cancelable: true
          });
          // If no handler responded, add it to body.
          if (!event.defaultPrevented) {
            document.body.appendChild(this.renderer);
          }
        }

        /**
         * Ensures the renderer is detached.
         */
        [_ensureDetached]() {
          if (!this.renderer || !this.renderer.isConnected) {
            return;
          }

          // Trigger event to notify.
          const event = this[_fire]('iron-overlay-detach', {
            overlay: this
          }, {
            node: this.renderer,
            cancelable: true
          });

          // Force removing.
          const parent = this.renderer.parentNode;
          parent && parent.removeChild(this.renderer);
        }

        [_openedChanged](opened) {
          if (!this.isConnected) {
            return;
          }
          if (opened) {
            this[_ensureAttached]();
          }
        }

        [_onTransitioningChanged](event) {
          if (event.target !== this.renderer) {
            return;
          }
          const transitioning = event.detail.value;
          if (transitioning) {
            this._toggleListeners();
          } else {
            this.applyFocus();
            if (this.opened) {
              this[_fire]('iron-overlay-opened');
            } else {
              this[_fire]('iron-overlay-closed', this.closingReason);
              this[_ensureDetached]();
            }
          }
        }

        [_fire](type, detail, options) {
          options = options || {};
          detail = (detail === null || detail === undefined) ? {} : detail;
          const event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          const node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

      }

      /**
       * Fired when the overlay should be attached.
       * @event iron-overlay-attach
       * @param {Event} event Call `event.preventDefault()` to notify the attach has been done.
       */

      /**
       * Fired when the content should be detached.
       * @event iron-overlay-detach
       * @param {Event} event Call `event.preventDefault()` to notify the detach has been done.
       */

      /**
       * Fired after the overlay has been fully opened.
       * @event iron-overlay-opened
       */

      /**
       * Fired when the overlay is canceled, but before it is closed.
       * @event iron-overlay-canceled
       * @param {Event} event Call `event.preventDefault()` to prevent the closing.
       * The `event.detail` is the original event that originated the canceling
       * (e.g. ESC keyboard event or click event outside the overlay).
       */

      /**
       * Fired after the overlay has been fully closed.
       * @event iron-overlay-closed
       * @param {Event} event The `event.detail` is the `closingReason` property
       * (e.g. `event.detail.canceled` is whether the overlay was canceled).
       */

      Polymer.IronOverlay = IronOverlay;
      customElements.define(IronOverlay.is, IronOverlay);
    })();
  </script>
</dom-module>
