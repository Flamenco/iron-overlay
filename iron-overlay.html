<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="iron-overlay-renderer.html">

<!--
`iron-overlay` is an element that can be hidden or shown, and displays on top of other content.
It can be used to implement a variety of UI controls including dialogs and drop downs.
Multiple overlays may be displayed at once.

`iron-overlay` delegates rendering of the overlay content to a renderer (`iron-overlay-renderer`).
It won't host the renderer, but request another element to host it through the
events `iron-overlay-attach` and `iron-overlay-detach`.
It requires overlay contents to be contained in a `<template>` (since they need to be hosted in the renderer).

Ensure to add an `iron-overlay-container` in your document in order to display
overlays. Insert it in a stacking-context safe node (e.g. `document.body`).

    <div style="transform: translateZ(0);">
      This div creates a new stacking context
      <iron-overlay opened>
        <template>
          <h2>Hello world!</h2>
        </template>
      </iron-overlay>
    </div>

    <iron-overlay-container></iron-overlay-container>


### Closing and canceling

An overlay may be hidden by closing or canceling. The difference between close and cancel is user
intent. Closing generally implies that the user acknowledged the content on the overlay. By default,
it will cancel whenever the user taps outside it or presses the escape key. This behavior is
configurable with the `no-cancel-on-esc-key` and the `no-cancel-on-outside-click` properties.
`close()` should be called explicitly by the implementer when the user interacts with a control
in the overlay element. When the overlay is canceled, it fires an 'iron-overlay-canceled'
event. Call `preventDefault` on this event to prevent the overlay from closing.


### Styling

`iron-overlay` sets its renderer attribute `data-overlay` to its id, so that
styling can be done like this:

    <style is="custom-style">
      iron-overlay-renderer {
        --iron-overlay-background-color: yellow;
      }
      iron-overlay-renderer[data-overlay="overlay1"] {
        --iron-overlay-background-color: orange;
      }
    </style>

    <iron-overlay-container></iron-overlay-container>

    <iron-overlay>
      <template>Overlay Content</template>
    </iron-overlay>
    <iron-overlay id="overlay1">
      <template>Overlay 1 Content</template>
    </iron-overlay>

@demo demo/index.html
 -->
<dom-module id="iron-overlay">
  <template>
    <template id="renderer-template">
      <iron-overlay-renderer></iron-overlay-renderer>
    </template>
    <slot></slot>
  </template>

  <script>
    (function() {
      'use strict';
      const templatizer = new Polymer.Templatizer();

      const _openedChanged = Symbol();
      const _ensureInstance = Symbol();
      const _ensureAttached = Symbol();
      const _ensureDetached = Symbol();
      const _onTransitioningChanged = Symbol();
      const _fire = Symbol();

      class IronOverlay extends Polymer.Element {

        static get is() {
          return 'iron-overlay';
        }

        static get config() {
          return {
            properties: {

              /**
               * True if the overlay is currently displayed.
               */
              opened: {
                type: Boolean,
                notify: true,
                observer: _openedChanged
              },

              /**
               * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
               * `iron-overlay` provides the `canceled` reason.
               */
              closingReason: {
                type: Object,
                readOnly: true,
                value: function() {
                  return {
                    canceled: false
                  };
                }
              },

              /**
               * Set to true to disable canceling the overlay with the ESC key.
               */
              noCancelOnEscKey: Boolean,

              /**
               * Set to true to disable canceling the overlay by clicking outside it.
               */
              noCancelOnOutsideClick: Boolean,

              /**
               * Set to true to disable auto-focusing the overlay or child nodes with
               * the `autofocus` attribute when the overlay is opened.
               */
              noAutoFocus: Boolean,

              /**
               * The renderer for the overlay.
               */
              renderer: {
                type: Polymer.IronOverlayRenderer,
                readOnly: true
              }
            }
          };
        }

        connectedCallback() {
          super.connectedCallback();
          this.opened && this[_openedChanged](this.opened);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this[_ensureDetached]();
        }

        /**
         * Toggle the opened state of the overlay.
         */
        toggle() {
          this.opened ? this.close() : this.open();
        }

        /**
         * Open the overlay.
         */
        open() {
          this.closingReason.canceled = false;
          this.opened = true;
        }

        /**
         * Close the overlay.
         */
        close() {
          this.closingReason.canceled = false;
          this.opened = false;
        }

        /**
         * Focuses the overlay if opened, blurs it if closed.
         */
        applyFocus() {
          if (this.noAutoFocus || !this.renderer || this.renderer.transitioning) {
            return;
          }
          const focusNode = this._getFocusNode();
          if (this.opened) {
            focusNode && focusNode.focus();
          } else {
            focusNode && focusNode.blur();
          }
        }

        /**
         * The node to be focused when the overlay is opened.
         * Defaults to the child with `autofocus` or the overlay itself.
         * @protected
         */
        _getFocusNode() {
          return this.renderer.querySelector('[autofocus]') || this.renderer.$.overlay;
        }

        /**
         * The template containing the renderer.
         * @type {!HTMLTemplateElement}
         * @protected
         */
        _getRendererTemplate() {
          return this.$['renderer-template'];
        }

        /**
         * The template containing the content to be stamped in the renderer.
         * @type {!HTMLTemplateElement}
         * @protected
         */
        _getContentTemplate() {
          return this.querySelector('template');
        }

        /**
         * Cancels the overlay.
         * @param {!Event} event The original event
         * @protected
         */
        _cancel(event) {
          const cancelEvent = this[_fire]('iron-overlay-canceled', event, {
            cancelable: true
          });
          if (!cancelEvent.defaultPrevented) {
            this.closingReason.canceled = true;
            this.opened = false;
          }
        }

        /**
         * @param {!Event} event
         * @protected
         */
        _onEsc(event) {
          // Avoid interactions while transitioning.
          if (!this.noCancelOnEscKey && !this.renderer.transitioning) {
            // If synthetic event, search for keyboard event in detail.
            const keyboardEvent = event.detail.keyboardEvent || event;
            this._cancel(keyboardEvent);
          }
        }

        /**
         * @param {!Event} event
         * @protected
         */
        _onTap(event) {
          // Avoid interactions while transitioning. Check if tap is outside.
          if (!this.noCancelOnOutsideClick && !this.renderer.transitioning && !this._isTapInside(event)) {
            // If synthetic event, search for source event in detail.
            const sourceEvent = event.detail.sourceEvent || event;
            this._cancel(sourceEvent);
          }
        }

        /**
         * @param {!Event} event
         * @returns {boolean}
         * @protected
         */
        _isTapInside(event) {
          return event.composedPath().indexOf(this.renderer.$.overlay) !== -1;
        }

        /**
         * Ensures the overlay is created and the content is stamped and appended into the overlay.
         */
        [_ensureInstance]() {
          if (this.renderer) {
            return;
          }
          // Init the renderer.
          const rendererInstance = new(templatizer.templatize(this._getRendererTemplate(), {
            fwdHostPropToInstance: function(host, prop, value) {
              rendererInstance && rendererInstance.forwardProperty(prop, value, host);
            }
          }))(this);
          const renderer = rendererInstance.root.children[0];
          renderer.dataset.overlay = this.id;
          renderer.addEventListener('transitioning-changed', this[_onTransitioningChanged].bind(this));

          // Stamp the content if any!
          const contentTemplate = this._getContentTemplate();
          if (contentTemplate) {
            const contentInstance = new(templatizer.templatize(contentTemplate, {
              fwdHostPropToInstance: function(host, prop, value) {
                contentInstance && contentInstance.forwardProperty(prop, value, host);
              }
            }))(this);
            // Append children to renderer.
            renderer.appendChild(contentInstance.root);
          }

          this._setRenderer(renderer);
        }

        /**
         * Ensures the renderer is attached.
         */
        [_ensureAttached]() {
          if (!this.renderer || this.renderer.isConnected) {
            return;
          }
          const event = this[_fire]('iron-overlay-attach', {
            overlay: this
          }, {
            cancelable: true
          });
          if (!event.defaultPrevented) {
            console.warn('overlay not attached!', this);
          }
        }

        /**
         * Ensures the renderer is detached.
         */
        [_ensureDetached]() {
          if (!this.renderer || !this.renderer.isConnected) {
            return;
          }
          const event = this[_fire]('iron-overlay-detach', {
            overlay: this
          }, {
            node: this.renderer,
            cancelable: true
          });
          if (!event.defaultPrevented) {
            console.warn('overlay not detached!', this);
          }
        }

        [_openedChanged](opened) {
          if (!this.isConnected) {
            return;
          }
          if (opened) {
            this[_ensureInstance]();
            this.renderer.opened = true;
            this[_ensureAttached]();
          } else if (this.renderer) {
            this.renderer.opened = false;
          }
        }

        [_onTransitioningChanged](event) {
          const transitioning = event.detail.value;
          if (event.target === this.renderer && !transitioning) {
            this.applyFocus();
            if (this.opened) {
              this[_fire]('iron-overlay-opened');
            } else {
              this[_ensureDetached]();
              this[_fire]('iron-overlay-closed', this.closingReason);
            }
          }
        }

        [_fire](type, detail, options) {
          options = options || {};
          detail = (detail === null || detail === undefined) ? {} : detail;
          const event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true: options.composed
          });
          event.detail = detail;
          const node = options.node || this;
          node.dispatchEvent(event);
          return event;
        }

      }

      /**
       * Fired when the overlay should be attached.
       * @event iron-overlay-attach
       * @param {Event} event Call `event.preventDefault()` to notify the attach has been done.
       */

      /**
       * Fired when the content should be detached.
       * @event iron-overlay-detach
       * @param {Event} event Call `event.preventDefault()` to notify the detach has been done.
       */

      /**
       * Fired after the overlay has been fully opened.
       * @event iron-overlay-opened
       */

      /**
       * Fired when the overlay is canceled, but before it is closed.
       * @event iron-overlay-canceled
       * @param {Event} event Call `event.preventDefault()` to prevent the closing.
       * The `event.detail` is the original event that originated the canceling
       * (e.g. ESC keyboard event or click event outside the overlay).
       */

      /**
       * Fired after the overlay has been fully closed.
       * @event iron-overlay-closed
       * @param {Event} event The `event.detail` is the `closingReason` property
       * (e.g. `event.detail.canceled` is whether the overlay was canceled).
       */

      Polymer.IronOverlay = IronOverlay;
      customElements.define(IronOverlay.is, IronOverlay);
    })();
  </script>
</dom-module>
