<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="iron-overlay-renderer-shared-styles.html">

<!--
`iron-overlay-renderer` renders the overlay content in the center of the screen,
and handles the switch from opened state to closed state & viceversa.

### Styling

`iron-overlay` sets its renderer attribute `data-overlay` to its id, so that
styling can be done like this:

    <style is="custom-style">
      iron-overlay-renderer {
        --iron-overlay-background-color: yellow;
      }
      [data-overlay="overlay1"] {
        --iron-overlay-background-color: orange;
      }
    </style>

    <iron-overlay-container></iron-overlay-container>

    <iron-overlay>
      <template>Overlay Content</template>
    </iron-overlay>
    <iron-overlay id="overlay1">
      <template>Overlay 1 Content</template>
    </iron-overlay>

@demo demo/index.html
-->

<dom-module id="iron-overlay-renderer">
  <template strip-whitespace>
    <style include="iron-overlay-renderer-shared-styles"></style>
    <div id="backdrop"></div>
    <div id="overlay" tabindex="0">
      <slot></slot>
    </div>
  </template>

  <script>
    (function() {
      'use strict';

      const _openedChanged = Symbol();
      const _startRenderOpenedChanged = Symbol();
      const _raf = Symbol();
      const _onNextAF = Symbol();
      const _forceLayout = Symbol();
      const _onTransitionEnd = Symbol();

      class IronOverlayRenderer extends Polymer.Element {

        static get is() {
          return 'iron-overlay-renderer';
        }

        static get config() {
          return {
            properties: {
              /**
               * True if the overlay is currently displayed.
               */
              opened: {
                type: Boolean,
                observer: _openedChanged
              },

              /**
               * True if the overlay has open/close animation.
               */
              animated: {
                type: Boolean
              },

              /**
               * True if the overlay should have a backdrop.
               */
              withBackdrop: {
                type: Boolean
              },

              /**
               * Is true during the transition from close to open and open to close.
               */
              transitioning: {
                type: Boolean,
                notify: true,
                readOnly: true
              }
            }
          };
        }

        constructor() {
          super();
          // For a performant transition from open to close and close to open.
          this[_raf] = null;
        }

        ready() {
          super.ready();
          this.$.overlay.addEventListener('transitionend', this[_onTransitionEnd].bind(this));
        }

        /**
         * Tasks to be performed to actually open/close. Override this to play
         * animations, and call `_finishRenderOpenedChanged()` when those are done.
         * @protected
         */
        _renderOpenedChanged() {
          // Doesn't wait for animations if animated is false.
          if (!this.animated) {
            this._finishRenderOpenedChanged();
          }
        }

        /**
         * @protected
         */
        _finishRenderOpenedChanged() {
          this._setTransitioning(false);
        }

        /**
         * @param {boolean} opened
         */
        [_openedChanged](opened) {
          this[_onNextAF](this[_startRenderOpenedChanged]);
        }

        /**
         * Starts the update from open to closed & viceversa.
         */
        [_startRenderOpenedChanged]() {
          this._setTransitioning(true);
          // Update interactions with element.
          this.style.pointerEvents = this.opened ? '' : 'none';
          // Need to force layout for any animation to trigger.
          if (this.animated) {
            this[_forceLayout]();
          }
          // Update classes for overlay and backdrop.
          this.$.overlay.classList.toggle('opened', this.opened);
          // Check if there is a backdrop in the shadow dom.
          this.$.backdrop && this.$.backdrop.classList.toggle('opened', this.opened);
          this._renderOpenedChanged();
        }

        /**
         * Forces layout.
         */
        [_forceLayout]() {
          return this.offsetWidth;
        }

        /**
         * Callback for transitionend, ends the animation.
         * @param {!Event} event
         */
        [_onTransitionEnd](event) {
          if (event.target === this.$.overlay) {
            // Since there might be multiple animations (e.g. opacity + transition),
            // call finish function only once (reuse RAF).
            this[_onNextAF](this._finishRenderOpenedChanged);
          }
        }

        /**
         * Executes the callback at the next available animation frame.
         * @param {!Function} callback Its scope will be the renderer itself
         */
        [_onNextAF](callback) {
          this[_raf] && window.cancelAnimationFrame(this[_raf]);
          const self = this;
          this[_raf] = window.requestAnimationFrame(function nextAnimationFrame() {
            self[_raf] = null;
            callback.call(self);
          });
        }

      }

      Polymer.IronOverlayRenderer = IronOverlayRenderer;
      customElements.define(IronOverlayRenderer.is, IronOverlayRenderer);

    })();
  </script>
</dom-module>
